# 페치조인


## 일반 조인

연관된 엔티티를 함께 조회하지 않는다.
1. Member엔티티를 조회한다.(이때 team은 프록시 객체를 가져온다. )
2. Member와 연관된 Team 엔티티 조회하는 쿼리, 총 2번의 쿼리 발생. (이때 진짜 team 엔티티 호출)

**⭐️엔티티의 연관관계는 fetch = FetchType.LAZY로 설정해줘야 하는데, 여기서 일반 조인을 사용하면 N+1 문제가 발생한다.**

## 페치 조인
  연관관계의 엔티티나 컬렉션을 프록시 객체가 아닌 진짜 데이터를 한번에 같이 조회하는 기능이다.
  JPQL에서 `성능 최적화`를 위해 사용된다.

###  엔티티 페치 조인
❓회원(Member)을 조회하면서 연관된 팀(Team)을 함께 조회하고 싶다면

```
[JPQL]
select m from Member m join fetch m.team

[SQL]
SELECT M*,T* from MEMBER M INNER JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
```

- 사용 이점: 내가 의도한 엔티티를 동적으로 조회할 수 있다.

## 컬렉션 페치 조인
- 일대다 관계 -  데이터가 뻥튀기 식으로 많아질 수 있다.
    - 왜냐하면 JPQL은 데이터가 있는 대로 나오기때문에 중복된 row가 나올 수 있다.

### DISTINCT
- 중복을 해결하기 위해 사용한다.
- **같은 식별자**를 가진 엔티티를 제거한다.


## ⭐페치 조인과 일반 조인의 차이
- 일반 조인: 연관 엔티티에 조인을 걸어도 실제 쿼리에서 조회하는 엔티티는 **오직 JPQL에서 조회하는 주체가 되는 엔티티만 영속화한다.**

- 페치 조인: 조회의 주체가 되는 엔티티 이외에 페치 조인에 걸린 **연관된 엔티티도 조회(즉시로딩)하여 모두 영속화한다.**

## ⭐⭐페치 조인의 특징
1. 연관된 엔티티를 한번에 조회(즉시 로딩) -  성능 최적화
2. 엔티티에 직접 적용하는 글로벌 로딩 전략(fetchType=LAZY) 보다 우선한다.
3. 실무에서는 `글로벌 로딩 전략은 모두 지연로딩` 으로 한다.
4. n+1 문제가 발생하여 최적화가 필요한 곳에는 `페치 조인`을 적용한다.
5. 만약 여러 테이블을 조회해야 되고 엔티티가 가진 모양이 아닌 전혀 다른 모양으로 결과를 내야 한다면 페치 조인보다 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적이다.

## 페치 조인의 한계
1. 페치 조인 대상에는 `별칭`을 줄 수 없다.  (하이버네이트 가능은 한데, 가급적 사용하지 말아라)
2. `둘 이상의 컬렉션`은 페치 조인 할 수 없다.
3. oneToMany, manyToMany 컬렉션을 페치 조인하면 `페이징 API를` 사용할 수 없다. 일대다 데이터를 조회하면 데이터 수가 변하기 때문에 페이징이 안된다.
- 위 문제를 해결하기 위해 batch_size 설정하는 등의 방식이 있다.

  (일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능하다.)
   