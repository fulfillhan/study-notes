## 엔티티 매니저 팩토리란?
엔티티 매니저를 생성하는 팩토리 객체이다. 즉 쉽게 생각하면 엔티티 매니저를 만드는 공장과 같다.

**특징**

- ` 생성 비용이 크기 `때문에 애플리케이션 시작 시 한 번만 생성해야 한다.
- 애플리케이션 전체에서` 단일 인스턴스`로 사용된다.
- `스레드에 안전하다`.

# 엔티티 매니저란?
엔티티 매니저는 엔티티의 저장,수정,삭제,조회등 엔티티와 관련된 모든 일을 처리한다.
(엔티티 매니저 팩토리를 통해서 엔티티 매니저를 생성한다.)
~~~
 EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
 EntityManager em = emf.createEntityManager();
~~~
**특징**
- `생성 비용이 작다.`
- `스레드에 안전하지 않기`에, 요청 또는 `트랜잭션 단위로 생성되어` 사용된다.
- 영속성 컨텍스트를 관리한다. 이는 엔티티의 상태를 관리하는 1차 캐시로 작동한다.
- 같은 트랜잭션 내에서는 동일한 엔티티를 여러 번 조회해도 동일한 객체를 반환한다.(동일성 보장)

**기능**
- persist() :  엔티티를 영속성 컨텍스트에 추가한다.
- merge() : 준영속 상태의 엔티티를 영속성 컨텍스트로 모두 병합한다.(실무에서 사용하지 않는 것이 좋다...)
- find() : 특정 ID를 사용해 엔티티 조회한다.
- createQuery(): JPQL 쿼리를 생성하고 실행한다.

# 영속성 컨텍스트란?
- 정의 :
    - 엔티티를 관리하고 데이터베이스와 상호작용하는 작업 단위이다. 쉽게 말하면 엔티티 객체를 저장하고 관리하는 1차 캐시 라고 볼 수 있다.
    - 특정 엔티티 메니저에 의해 생성된다.
- 기능:
    - 엔티티 상태를 관리
    - 데이터베이스와 동기화
    - 동일성 보장

- 특징:
1. 1차 캐시
    - 영속성 컨텍스트는 엔티티를 1차 캐시로 저장한다.
    - 따라서, `같은 트랜잭션내`에서 동일한 엔티티를 여러번 호출하면 DB에서 가져오는 것이 아니라 `1차 캐시에서 반환한다.`

2. 변경 감지(Dirty Checking)
    - 상단에 엔티티 매니저의 기능중 merge 병합이 있는데, 이 두가지를 잘 구별할 수 있어야 한다.
      영속성 컨택스트에 저장된 엔티티가 변경되면, 트랜잭션 커밋 시점에 자동으로 변경 속성을 하나씩 감지하고 DB에 반영한다.
3. 영속 엔티티의 동일성 보장(결국 1차 캐시가 가능하기 때문이다.)
    - 동일한 영속성 컨텍스트 내에서는 같은 엔티티 ID를 가진 객체는 항상 같은 인스턴스이다.
4. 지연 로딩(LAZY)
    - 영속성 컨텍스트가 엔티티의 상태를 관리하기 때문에 JPA에서 연관된 엔티티를 실체로 사용할 때 DB에서 조회하는 것이 아니라,
      영속성 컨텍스트를 통해 조회한다.
5. 쓰기 지연(Batch Writing)
    - 영속성 컨텍스트내에는 쓰기 지연 sql저장소가 있다.
    - 트랜잭션이 끝날 때까지 sql쿼리를 쓰기 지연 sql저장소에 모아두었다가 커밋 하는 순간에 한 번에 실행한다.
      이를 통해 데이터 베이스와의 상호작용에서 오는 성능비용을 줄일 수 있다.

# 엔티티의 상태
- 비영속: 영속성 컨텍스트와 `전혀 관계가 없는` 상태

- 영속 : 영속성 컨텍스트에서 `관리`되는 상태(DB에 저장되는 것은 아니다!)
~~~
    //객체를 생성한 상태(비영속)
    Member member = new Member();
    member.setName("memberA");
    
    EntityManager em = emf.createEntityManager();
    em.getTransaction().begin();
    
    //객체를 저장한 상태(영속)
    em.persist(member);
~~~

- 준영속 : 영속성 컨텍스트에서 관리되었다가 `분리된` 상태로 영속성 컨텍스트에서 관리되지 않는다.
- 삭제 : 삭제된 상태

# 플러시
영속성 컨텍스트의 변경내용을 데이터베이스에 반영한다.
(트랜잭션 커밋이 발생하면 플러시는 자동으로 발생한다.)
~~~
em.flush();//플러시 강제 호출
~~~
### <플러시 과정>
- 변경 감지
- 수정된 엔티티 쓰기 지연 sql저장소에 등록한다.
- 저장된 쿼리를 db에 바로 반영한다.

📌중요
- 플러쉬를 바로 한다고 영속성 컨텍스트를 비우는 것은 아니다.!
- 영속성 컨텍스트의 변경 내용을 데이터베이스와 동기화한다.
- 트랜잭션이라는 작업 단위가 중요 --> `커밋 직전에만 동기화`하면 된다.

# 준영속
영속 상태의 엔티티가 영속성 컨텍스트에서 `분리된` 상태

### ◾준영속 상태로 만드는 방법
```
Member findMember = em.find(Member.class, 101L);  //findMember는 영속 상태!

em.detach(findMember);  // 준영속 상태 : jpa에서 관리되지 않는다.
em.clear();             //영속성 컨텍스트 완전히 초기화
em.close();             // 영속성 컨텍스트 종료
```